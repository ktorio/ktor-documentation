<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd"
       title="Create RESTful APIs that generate JSON" id="create-restful-apis">
    <show-structure for="chapter" depth="2"/>
    <tldr>
        <var name="example_name" value="tutorial-server-restful-api"/>
        <include from="lib.topic" element-id="download_example"/>
    </tldr>
    <p>
        In the <a href="">previous tutorial</a>, we introduced you to the
        fundamentals of validation, error handling, and unit testing. This article will expand on these topics by
        creating a RESTful service for managing tasks.
    </p>
    <p>
        This tutorial will teach you how to do the following:
    </p>
    <list>
        <li>Create RESTful services that use JSON serialization.</li>
        <li>Understand the process of <a href="server-serialization.md">Content Negotiation</a>.</li>
        <li>Define the routes for a REST API within Ktor.</li>
    </list>
    <chapter title="Prerequisites" id="prerequisites">
        <p>This is the third tutorial in the Get started with Ktor Server guide. You can do this tutorial independently,
            however, we strongly recommend that you complete the preceding tutorial to learn how to <a
                    href="">handle requests and generate responses</a>
            .
        </p>
        <p>We recommend that you install <a href="https://www.jetbrains.com/help/idea/installation-guide.html">IntelliJ
            IDEA</a>, but you could use another IDE of your choice.
        </p>
    </chapter>
    <chapter title="Hello RESTful Task Manager" id="hello-restful-task-manager">
        <p>In this tutorial, you will be rewriting your existing Task Manager as a RESTful service. To do this you will
            use several Ktor modules.</p>
        <p>
            You could manually add these to your existing project, but it’s simpler to generate a new project and then
            incrementally port the code from the previous tutorial. You will reiterate all the code as you go, so you
            don’t need to have the previous project to hand.
        </p>
        <procedure title="Create a new project with plugins">
            <step>
                <include from="lib.topic" element-id="generate_project_step_1"/>
            </step>
            <step>
                <p>In the
                    <control>Project Name</control>
                    field, enter "ktor-rest-task-app" as the name of your project.
                </p>
                <img src="tutorial_creating_restful_apis_project_name.png"
                     alt="Naming the project in the Ktor Project Generator"
                     border-effect="line"
                     width="706"/>
            </step>
            <step>
                <p>You can leave the default values for the rest of the settings and click on
                    <control>Add plugins</control>
                    to go to the next screen.
                </p>
            </step>
            <step>
                <p>
                    In the plugins section search for and add the following plugins by clicking on the
                    <control>Add</control>
                    button:
                </p>
                <list type="bullet">
                    <li>Routing</li>
                    <li>Content Negotiation</li>
                    <li>Kotlinx.serialization</li>
                    <li>Static Content</li>
                </list>
                <img src="ktor_project_generator_add_plugins.gif" alt="Adding plugins in the Ktor Project Generator"
                     border-effect="line"
                     width="400"/>
            </step>
            <step>
                <p>
                    Once you have added the plugins, click on the
                    <control>4 plugins added</control>
                    link at the bottom left, to display the added plugins.
                </p>
                <p>You will then see a list of all the plugins that will be added to your project:</p>
                <img src="tutorial_creating_restful_apis_plugins_list.png"
                     alt="Plugins list in the Ktor Project Generator"
                     border-effect="line"
                     width="400"/>
            </step>
            <step>
                <include from="lib.topic" element-id="generate_project_final_step"/>
            </step>
        </procedure>
        <procedure title="Add starter code" id="add-starter-code">
            <step>
                <p>Open your project in IntelliJ IDEA, as previously described in the <a
                        href="server-create-a-new-project.topic#open-explore-run">Create, open and run a Ktor
                    project</a> tutorial.</p>
            </step>
            <step>
                <p>
                    Navigate to
                    <path>src/main/kotlin/com/example</path>
                    and create a subpackage called "model".
                </p>
            </step>
            <step>
                <p>
                    Inside the
                    <path>model</path>
                    package, create a new
                    <path>.kt</path>
                    file called "Task".
                </p>
            </step>
            <step>
                <p>
                    As in the previous tutorial, you will add an <code>enum</code> to represent priorities and a <code>class</code>
                    to represent tasks. Add the following to the
                    <path>Task.kt</path>
                    file:
                </p>
                <code-block lang="kotlin">
                    package com.example.model

                    import kotlinx.serialization.Serializable

                    enum class Priority {
                        Low, Medium, High, Vital
                    }

                    @Serializable
                    data class Task(
                        val name: String,
                        val description: String,
                        val priority: Priority
                    )
                </code-block>
                <p>
                    In the previous tutorial you used extension functions to convert Tasks into HTML. In this case, the
                    <code>Task</code> class is annotated with the <a
                        href="https://kotlinlang.org/api/kotlinx.serialization/kotlinx-serialization-core/kotlinx.serialization/-serializable/">Serializable</a>
                    type from the
                    <code>kotlinx.serialization</code> library.
                </p>
            </step>
            <step>
                <p>
                    Open the
                    <path>Routing.kt</path>
                    file and replace the existing code with the
                    implementation below:
                </p>
                <code-block lang="kotlin">
                    package com.example.plugins

                    import com.example.model.*
                    import io.ktor.server.application.*
                    import io.ktor.server.http.content.*
                    import io.ktor.server.response.*
                    import io.ktor.server.routing.*

                    fun Application.configureRouting() {
                        routing {
                            staticResources("static", "static")

                            get("/tasks") {
                                call.respond(
                                    listOf(
                                        Task("cleaning", "Clean the house", Priority.Low),
                                        Task("gardening", "Mow the lawn", Priority.Medium),
                                        Task("shopping", "Buy the groceries", Priority.High),
                                        Task("painting", "Paint the fence", Priority.Medium)
                                    )
                                )
                            }
                        }
                    }
                </code-block>
                <p>
                    Similar to the previous tutorial, you’ve created a route for GET requests to the URL
                    <code>/tasks</code>.
                    This time, instead of manually converting the list of tasks, you are simply returning the list.
                </p>
            </step>
            <step>
                <p>In IntelliJ IDEA, click the run button <img src="intellij_idea_gutter_icon.svg"
                                                               style="inline" height="16" width="16"
                                                               alt="intelliJ IDEA run icon"/> to start the
                    application.
                </p>
            </step>
            <step>
                <p>
                    Navigate to <a href="http://0.0.0.0:8080/tasks">http://0.0.0.0:8080/tasks</a> in your browser. You
                    should see a JSON version of the list of tasks, as shown below:
                </p>
            </step>
            <img src="tutorial_creating_restful_apis_starter_code_preview.png"
                 alt="JSON data displayed in a browser screen"
                 border-effect="rounded"
                 width="706"/>
            <p>Clearly a lot of work is being performed on our behalf. What exactly is going on?</p>
        </procedure>
    </chapter>
    <chapter title="Understand Content Negotiation" id="content-negotiation">
        <chapter title="Content Negotiation via the browser" id="via-browser">
            <p>
                When you created the project you included the <a href="server-serialization.md">Content Negotiation</a> plugin.
                This plugin looks at the types
                of content that the client can render and matches these against the content types that the current
                service can provide. Hence, the term
                <format style="italic">Content Negotiation</format>
                .
            </p>
            <p>
                In HTTP the client signals which content types it can render through the <code>Accept</code> header. The
                value of this header is one or more content types. In the case above you can examine the value of this
                header by using the development tools built into your browser.
            </p>
            <p>
                Consider the following example:
            </p>
            <code-block>
                text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
            </code-block>
            <p>Note the inclusion of “*/*”.This header signals that it accepts HTML, XML or Images - but it would also accept any other content
                type.</p>
            <p>The Content Negotiation plugin needs to find a format to send data back to the browser. If you look
                inside the generated code in the project you will find a file called
                <path>Serialization.kt</path>
                inside
                <path>src/kotlin/main/com/example/plugins</path>
                , which includes the following:
            </p>
            <code-block lang="kotlin">
                install(ContentNegotiation) {
                    json()
                }
            </code-block>
            <p>
                This code installs the <code>ContentNegotiation</code> plugin, and also configures the <code>kotlinx.serialization</code>
                plugin. With this, when clients send requests the server can send back objects serialized as JSON.
            </p>
            <p>
                In the case of the request from the browser the Content Negotiation plugin knows it can only return
                JSON, and the browser will try to display anything it is sent. So the request succeeds.
            </p>
        </chapter>
        <chapter title="Content Negotiation via JavaScript" id="via-javascript">
            <p>
                In a production environment, you wouldn’t want to display JSON directly in the browser. Instead, there
                would be JavaScript code running within the browser, which would make the request and then display the
                data returned as part of a Single Page Application (SPA). Typically, this kind of application would be
                written using a framework like React, Angular, or Vue.js.
            </p>
            <p>
                To simulate this, open the
                <path>index.html</path>
                page inside
                <path>src/main/resources/static</path>
                and replace the default content with the following:
            </p>
            <code-block lang="html"><![CDATA[
                <html>
                <head>
                    <title>A Simple SPA For Tasks</title>
                    <script type="application/javascript">
                        function fetchAndDisplayTasks() {
                            fetchTasks()
                                .then(tasks => displayTasks(tasks))
                            }

                        function fetchTasks() {
                            return fetch(
                                "/tasks",
                                {
                                    headers: { 'Accept': 'application/json' }
                                }
                            ).then(resp => resp.json());
                        }

                        function displayTasks(tasks) {
                            const tasksTableBody = document.getElementById("tasksTableBody")
                            tasks.forEach(task => {
                                const newRow = taskRow(task);
                                tasksTableBody.appendChild(newRow);
                            });
                        }

                        function taskRow(task) {
                            return tr([
                                td(task.name),
                                td(task.description),
                                td(task.priority)
                            ]);
                        }

                        function tr(children) {
                            const node = document.createElement("tr");
                            children.forEach(child => node.appendChild(child));
                            return node;
                        }

                        function td(text) {
                            const node = document.createElement("td");
                            node.appendChild(document.createTextNode(text));
                            return node;
                        }
                    </script>
                </head>
                <body>
                <h1>Viewing Tasks Via JS</h1>
                <form action="javascript:fetchAndDisplayTasks()">
                    <input type="submit" value="View The Tasks">
                </form>
                <table>
                    <thead>
                        <tr><th>Name</th><th>Description</th><th>Priority</th></tr>
                    </thead>
                    <tbody id="tasksTableBody">
                    </tbody>
                </table>
                </body>
                </html>
            ]]>
            </code-block>
            <p>
                This page contains an HTML form and an empty table. When you submit the form a JavaScript event handler
                sends a request to the <code>/tasks</code> endpoint, with the <code>Accept</code> header set to
                <code>application/json</code>. The data returned is then de-serialized and added to an HTML table.
            </p>
            <p>
                In IntelliJ IDEA, click the rerun button <img src="intellij_idea_rerun_icon.svg"
                                                              style="inline" height="16" width="16"
                                                              alt="intelliJ IDEA rerun icon"/> to restart the
                application.
            </p>
            <p>
                If you navigate to the URL <a href="http://0.0.0.0:8080/static/index.html">http://0.0.0.0:8080/static/index.html</a>
                you should be able to fetch the data by clicking on the
                <control>View The Tasks</control>
                button:
            </p>
            <img src="tutorial_creating_restful_apis_tasks_via_js.png"
                 alt="A browser window showing a button and tasks displayed as an HTML table"
                 border-effect="line"
                 width="706"/>
        </chapter>
    </chapter>
    <chapter title="Add the GET routes" id="porting-get-routes">
        <p>
            Now that you are familiar with the process of content negotiation, continue with transferring the
            functionality
            from the <a href="">previous tutorial</a> into this one.
        </p>
        <procedure title="Reuse the Task Repository" id="task-repository">
            <p>
                You can reuse the repository for Tasks without any modification, so let’s do that first.
            </p>
            <p>
                Inside the
                <path>model</path>
                package create a new
                <path>.kt</path>
                file called "TaskRepository" and add the code below:
            </p>
            <code-block lang="kotlin">
                <![CDATA[
                package com.example.model

                object TaskRepository {
                    private val tasks = mutableListOf(
                        Task("cleaning", "Clean the house", Priority.Low),
                        Task("gardening", "Mow the lawn", Priority.Medium),
                        Task("shopping", "Buy the groceries", Priority.High),
                        Task("painting", "Paint the fence", Priority.Medium)
                    )

                    fun allTasks(): List<Task> = tasks

                    fun tasksByPriority(priority: Priority) = tasks.filter {
                        it.priority == priority
                    }

                    fun taskByName(name: String) = tasks.find {
                        it.name.equals(name, ignoreCase = true)
                    }

                    fun addTask(task: Task) {
                        if (taskByName(task.name) != null) {
                            throw IllegalStateException("Cannot duplicate task names!")
                        }
                        tasks.add(task)
                    }
                }
                ]]>
            </code-block>
        </procedure>
        <procedure title="Reuse the routes for GET requests" id="get-requests">
            <p>
                Now that you’ve created the repository you can implement all the routes for GET requests. The previous
                code can be simplified because you no longer need to worry about converting tasks to HTML:
            </p>
            <step>
                <p>
                    Navigate to the
                    <path>Routing.kt</path>
                    file in
                    <path>src/main/kotlin/com/example/plugins</path>
                    .
                </p>
            </step>
            <step>
                <p>
                    Update the code for the <code>/tasks</code> route inside the
                    <code>Application.configureRouting()</code> function with the following implementation:
                </p>
                <code-block lang="kotlin">
                    fun Application.configureRouting() {
                        routing {
                            staticResources("static", "static")

                            //updated implementation
                            route("/tasks") {
                                get {
                                    val tasks = TaskRepository.allTasks()
                                    call.respond(tasks)
                                }

                                get("/byName/{taskName}") {
                                    val name = call.parameters["taskName"]
                                    if (name == null) {
                                        call.respond(HttpStatusCode.BadRequest)
                                        return@get
                                    }

                                    val task = TaskRepository.taskByName(name)
                                    if (task == null) {
                                        call.respond(HttpStatusCode.NotFound)
                                        return@get
                                    }
                                    call.respond(task)
                                }
                                get("/byPriority/{priority}") {
                                    val priorityAsText = call.parameters["priority"]
                                    if (priorityAsText == null) {
                                        call.respond(HttpStatusCode.BadRequest)
                                        return@get
                                    }
                                    try {
                                        val priority = Priority.valueOf(priorityAsText)
                                        val tasks = TaskRepository.tasksByPriority(priority)

                                        if (tasks.isEmpty()) {
                                            call.respond(HttpStatusCode.NotFound)
                                            return@get
                                        }
                                        call.respond(tasks)
                                    } catch (ex: IllegalArgumentException) {
                                        call.respond(HttpStatusCode.BadRequest)
                                    }
                                }
                            }
                        }
                    }
                </code-block>
                <p>
                    With this, your server can respond to the following GET requests:</p>
                <list>
                    <li><code>/tasks</code> returns all tasks in the repository.</li>
                    <li><code>/tasks/byName/{taskName}</code> returns tasks filtered by the specified
                        <code>taskName</code>.
                    </li>
                    <li><code>/tasks/byPriority/{priority}</code> returns tasks filtered by the specified
                        <code>priority</code>.
                    </li>
                </list>
            </step>
        </procedure>
        <chapter title="Test the functionality" id="test-tasks-routes">
            <procedure title="Use the browser">
                <p>You could test these routes in the browser. For example, you can navigate to <a
                        href="http://0.0.0.0:8080/tasks/byPriority/Medium">http://0.0.0.0:8080/tasks/byPriority/Medium</a>
                    to see all the tasks with a medium priority displayed in JSON format:</p>
                <img src="tutorial_creating_restful_apis_tasks_medium_priority.png"
                     alt="A browser window showing tasks with medium priority in JSON format"
                     border-effect="rounded"
                     width="706"/>
                <p>
                    Given that these kinds of requests will typically be coming from JavaScript, more
                    fine-grained testing is preferable. For this, you can use a specialist tool such as <a
                        href="https://learning.postman.com/docs/sending-requests/requests/">Postman</a>.
                </p>
            </procedure>
            <procedure title="Use Postman">
                <step>
                    <p>In Postman, create a new GET request with the URL
                        <code>http://0.0.0.0:8080/tasks/byPriority/Medium</code>.</p>
                </step>
                <step>
                    <p>
                        In the
                        <ui-path>Headers</ui-path>
                        pane, set the value of the
                        <ui-path>Accept</ui-path>
                        header to <code>application/json</code>.
                    </p>
                </step>
                <step>
                    <p>Click
                        <control>Send</control>
                        to send the request and see the response in the response viewer.
                    </p>
                    <img src="tutorial_creating_restful_apis_tasks_medium_priority_postman.png"
                         alt="A GET request in Postman showing tasks with medium priority in JSON format"
                         border-effect="rounded"
                         width="706"/>
                </step>
            </procedure>
            <procedure title="Use an HTTP Request File">
                <p>Within IntelliJ IDEA Ultimate you could perform the same steps in an HTTP Request file.</p>
                <step>
                    <p>
                        In the project root directory, create a new
                        <path>.http</path>
                        with the name "REST Task Manager".
                    </p>
                </step>
                <step>
                    <p>
                        Open the
                        <path>REST Task Manager.http</path>
                        file and add the following GET request:
                    </p>
                    <code-block lang="http">
                        GET http://0.0.0.0:8080/tasks/byPriority/Medium
                        Accept: application/json
                    </code-block>
                </step>
                <step>
                    <p>
                        To send the request within the IntelliJ IDE, click on the gutter icon (<img
                            alt="intelliJ IDEA gutter icon"
                            src="intellij_idea_gutter_icon.svg"
                            width="16" height="26"/>) next to it.
                    </p>
                </step>
                <step>
                    <p>This will open and run in the
                        <path>Services</path>
                        tool window:
                    </p>
                    <img src="tutorial_creating_restful_apis_tasks_medium_priority_http_file.png"
                         alt="A GET request in an HTTP file showing tasks with medium priority in JSON format"
                         border-effect="rounded"
                         width="706"/>
                </step>
            </procedure>
            <note>
                Another way to test the routes can be to use the <a
                    href="https://khttp.readthedocs.io/en/latest/">khttp</a> library from within a Kotlin
                Notebook.
            </note>
        </chapter>
    </chapter>
    <chapter title="Add a route for POST requests" id="add-a-route-for-post-requests">
        <p>
            In the previous tutorial, tasks were created through an HTML form. However, as you are now building a
            RESTful service, you no longer need to do that. Instead, you will make use of the <code>kotlinx.serialization</code>
            framework which will do the majority of the heavy lifting.
        </p>
        <procedure>
            <step>
                <p>
                    Open the
                    <path>Routing.kt</path>
                    file inside
                    <path>src/main/kotlin/com/example/plugins</path>
                    .
                </p>
            </step>
            <step>
                <p>
                    Add a new POST route to the <code>Application.configureRouting()</code> function as follows:
                </p>
                <code-block lang="kotlin"><![CDATA[
                    fun Application.configureRouting() {
                        routing {
                            //...

                            route("/tasks") {
                                //...

                                //add the following new route
                                post {
                                    try {
                                        val task = call.receive<Task>()
                                        TaskRepository.addTask(task)
                                        call.respond(HttpStatusCode.NoContent)
                                    } catch (ex: IllegalStateException) {
                                        call.respond(HttpStatusCode.BadRequest)
                                    } catch (ex: JsonConvertException) {
                                        call.respond(HttpStatusCode.BadRequest)
                                    }
                                }
                            }
                        }
                    }
                ]]></code-block>
                <p>
                    Add the following new imports:
                </p>
                <code-block lang="kotlin">
                    //...
                    import io.ktor.serialization.*
                    import io.ktor.server.request.*
                </code-block>
                <p>
                    When a POST request is sent to <code>/tasks</code> the <code>kotlinx.serialization</code> framework
                    is used to convert the body of the request into a <code>Task</code> object. If this succeeds, the
                    task will be added to the repository. If the deserialization process fails the server will need to
                    handle a <code>JsonConvertException</code>, whereas if the task is a duplicate it will need to
                    handle an <code>IllegalStateException</code>.
                </p>
            </step>
            <step>
                <p>
                    Restart the application.
                </p>
            </step>
            <step>
                <p>
                    To test this functionality in Postman, create a new POST request to the URL <code>http://0.0.0.0:8080/tasks</code>.
                </p>
            </step>
            <step>
                <p>
                    In the
                    <ui-path>Body</ui-path>
                    pane add the following JSON document to represent a new task:
                </p>
                <code-block lang="json">
                    {
                        “name”: “cooking”,
                        “description”: “Cook the dinner”,
                        “priority”: “High”
                    }
                </code-block>
                <img src="tutorial_creating_restful_apis_add_task.png"
                     alt="A POST request in Postman for adding a new task"
                     border-effect="line"
                     width="706"/>
            </step>
            <step>
                <p>Click
                    <control>Send</control>
                    to send the request.
                </p>
            </step>
            <step>
                <p>
                    You can verify the task has been added by sending a GET request to <a
                        href="http://0.0.0.0:8080/tasks">http://0.0.0.0:8080/tasks</a>
                    .
                </p>
            </step>
            <step>
                <p>
                    Within IntelliJ IDEA Ultimate you could perform the same steps by adding the following to your HTTP
                    Request file:
                </p>
                <code-block lang="http">
                    ###

                    POST http://0.0.0.0:8080/tasks
                    Content-Type: application/json

                    {
                        "name": "cooking",
                        "description": "Cook the dinner",
                        "priority": "High"
                    }
                </code-block>
            </step>
        </procedure>
    </chapter>
    <chapter title="Add support for removals" id="remove-tasks">
        <p>
            You have almost finished adding the basic operations to your service. These are often summarized as the CRUD
            operations - short for Create, Read, Update, and Delete. The only operation you are missing is the Delete.
        </p>
        <procedure>
            <step>
                <p>
                    In the
                    <path>TaskRepository.kt</path>
                    file add the following method within the <code>TaskRepository</code> object to remove tasks based on
                    their name:
                </p>
                <code-block lang="kotlin">
                    fun removeTask(name: String): Boolean {
                        return tasks.removeIf { it.name == name }
                    }
                </code-block>
            </step>
            <step>
                <p>
                    Open the
                    <path>Routing.kt</path>
                    file and add an endpoint into the <code>routing()</code> function to handle DELETE requests:
                </p>
                <code-block lang="kotlin">
                    fun Application.configureRouting() {
                        //...

                        routing {
                            route("/tasks") {
                                //...
                                //add the following function
                                delete("/{taskName}") {
                                    val name = call.parameters["taskName"]
                                    if (name == null) {
                                        call.respond(HttpStatusCode.BadRequest)
                                        return@delete
                                    }

                                    if (TaskRepository.removeTask(name)) {
                                        call.respond(HttpStatusCode.NoContent)
                                    } else {
                                        call.respond(HttpStatusCode.NotFound)
                                    }
                                }
                            }
                        }
                    }
                </code-block>
            </step>
            <step>
                <p>
                    Restart the application.
                </p>
            </step>
            <step>
                <p>
                    Add the following DELETE request to your HTTP Request File:
                </p>
                <code-block lang="http">
                    ###

                    DELETE http://0.0.0.0:8080/tasks/gardening
                </code-block>
            </step>
            <step>
                <p>
                    To send the DELETE request within IntelliJ IDE, click on the gutter icon (<img
                        alt="intelliJ IDEA gutter icon"
                        src="intellij_idea_gutter_icon.svg"
                        width="16" height="26"/>) next to it.
                </p>
            </step>
            <step>
                <p>You will see the response in the
                    <path>Services</path>
                    tool window:
                </p>
                <img src="tutorial_creating_restful_apis_delete_task.png"
                     alt="A DELETE request in an HTTP Request file"
                     border-effect="line"
                     width="706"/>
            </step>
        </procedure>
    </chapter>
    <chapter title="Create unit tests with Ktor Client" id="create-unit-tests">
        <p>
            So far you have tested your application manually but, as you’ve already noticed, this approach is
            time-consuming and will not scale. Instead, you can implement JUnit tests, using the built-in
            <code>client</code> object to fetch and deserialize JSON.
        </p>
        <procedure>
            <step>
                <p>
                    Open the
                    <path>ApplicationTest.kt</path>
                    file within
                    <path>src/test/kotlin/com/example</path>
                    .
                </p>
            </step>
            <step>
                <p>
                    Replace the contents of the
                    <path>ApplicationTest.kt</path>
                    file with the following:
                </p>
                <code-block lang="kotlin"><![CDATA[
                package com.example

                import io.ktor.client.call.*
                import io.ktor.client.plugins.contentnegotiation.*
                import io.ktor.client.request.*
                import io.ktor.http.*
                import io.ktor.serialization.kotlinx.json.*
                import io.ktor.server.testing.*
                import com.example.model.*
                import kotlin.test.*

                class ApplicationTest {
                    @Test
                    fun tasksCanBeFoundByPriority() = testApplication {
                        val client = createClient {
                            install(ContentNegotiation) {
                                json()
                            }
                        }

                        val response = client.get("/tasks/byPriority/Medium")
                        val results = response.body<List<Task>>()

                        assertEquals(HttpStatusCode.OK, response.status)

                        val expectedTaskNames = listOf("gardening", "painting")
                        val actualTaskNames = results.map(Task::name)
                        assertContentEquals(expectedTaskNames, actualTaskNames)
                    }

                    @Test
                    fun invalidPriorityProduces400() = testApplication {
                        val response = client.get("/tasks/byPriority/Invalid")
                        assertEquals(HttpStatusCode.BadRequest, response.status)
                    }


                    @Test
                    fun unusedPriorityProduces404() = testApplication {
                        val response = client.get("/tasks/byPriority/Vital")
                        assertEquals(HttpStatusCode.NotFound, response.status)
                    }

                    @Test
                    fun newTasksCanBeAdded() = testApplication {
                        val client = createClient {
                            install(ContentNegotiation) {
                                json()
                            }
                        }

                        val task = Task("swimming", "Go to the beach", Priority.Low)
                        val response1 = client.post("/tasks") {
                            header(
                                HttpHeaders.ContentType,
                                ContentType.Application.Json
                            )

                            setBody(task)
                        }
                        assertEquals(HttpStatusCode.NoContent, response1.status)

                        val response2 = client.get("/tasks")
                        assertEquals(HttpStatusCode.OK, response2.status)

                        val taskNames = response2
                            .body<List<Task>>()
                            .map { it.name }

                        assertContains(taskNames, "swimming")
                    }
                }
                ]]></code-block>
                <p>
                    Note that you need to install the <code>ContentNegotiation</code> and
                    <code>kotlinx.serialization</code> plugins into the client, in the same way as you did on the
                    server.
                </p>
            </step>
            <step>
                <p>
                    Add the following dependency into your
                    <path>build.gradle.kts</path>
                    file:
                </p>
                <code-block lang="kotlin">
                    testImplementation("io.ktor:ktor-client-content-negotiation:$ktor_version")
                </code-block>
            </step>
        </procedure>
    </chapter>
    <chapter title="Create unit tests with JsonPath" id="unit-tests-via-jsonpath">
        <p>
            Testing your service with the Ktor client, or a similar library, is convenient, but it has a drawback from a
            QA perspective. The server, not directly handling JSON, can't be certain about its assumptions regarding the
            JSON structure.
        </p>
        <p>
            For example, assumptions like:
        </p>
        <list>
            <li>Values are being stored in an <code>array</code> when in reality an <code>object</code> is used.</li>
            <li>Properties are being stored as <code>numbers</code>, when they are in fact <code>strings</code>.</li>
            <li>Members are being serialized in the order of declaration when they are not.</li>
        </list>
        <p>
            If your service is intended for use by multiple clients, it's crucial to have confidence in the JSON
            structure. To achieve this, use the Ktor Client to retrieve text from the server and then analyze this
            content using the JSONPath library.</p>
        <procedure>
            <step>
                <p>In your
                    <path>build.gradle.kts</path>
                    file, add the JSONPath library as a test dependency:
                </p>
                <code-block lang="kotlin">
                    testImplementation("com.jayway.jsonpath:json-path:2.9.0")
                </code-block>
            </step>
            <step>
                <p>
                    Navigate to the
                    <path>src/test/kotlin/com/example</path>
                    folder and create a new
                    <path>.kt</path>
                    file called "ApplicationJsonPathTest".
                </p>
            </step>
            <step>
                <p>
                    Add the following content to the
                    <path>ApplicationJsonPathTest.kt</path>
                    file:
                </p>
                <code-block lang="kotlin">
                    <![CDATA[
package com.example

import com.jayway.jsonpath.DocumentContext
import com.jayway.jsonpath.JsonPath
import io.ktor.client.*
import com.example.model.Priority
import io.ktor.client.request.*
import io.ktor.client.statement.*
import io.ktor.http.*
import io.ktor.server.testing.*
import kotlin.test.*


class ApplicationJsonPathTest {
    @Test
    fun tasksCanBeFound() = testApplication {
        val jsonDoc = client.getAsJsonPath("/tasks")

        val result: List<String> = jsonDoc.read("$[*].name")
        assertEquals("cleaning", result[0])
        assertEquals("gardening", result[1])
        assertEquals("shopping", result[2])
    }

    @Test
    fun tasksCanBeFoundByPriority() = testApplication {
        val priority = Priority.Medium
        val jsonDoc = client.getAsJsonPath("/tasks/byPriority/$priority")

        val result: List<String> =
            jsonDoc.read("$[?(@.priority == '$priority')].name")
        assertEquals(2, result.size)

        assertEquals("gardening", result[0])
        assertEquals("painting", result[1])
    }

    suspend fun HttpClient.getAsJsonPath(url: String): DocumentContext {
        val response = this.get(url) {
            accept(ContentType.Application.Json)
        }
        return JsonPath.parse(response.bodyAsText())
    }
}
                ]]></code-block>
                <p>
                    The JsonPath queries work as follows:
                </p>
                <list>
                    <li>
                        <code>$[*].name</code> means “treat the document as an array and return the value of the name
                        property of each entry”.
                    </li>
                    <li>
                        <code>$[?(@.priority == '$priority')].name</code> means “return the value of the name property
                        of every entry in the array with a priority equal to the supplied value”.
                    </li>
                </list>
                <p>
                    You can use queries like these to confirm your understanding of the returned JSON. When you do code
                    refactoring and service redeployment, any modifications in serialization will be identified, even if
                    they don't disrupt deserialization with the current framework. This allows you to republish publicly
                    available APIs with confidence.
                </p>
            </step>
        </procedure>
    </chapter>
    <chapter title="Next steps" id="next-steps">
        <p>
            Congratulations! You have now completed creating a RESTful API service for your Task Manager application and
            learned the nits and grits of unit testing with the Ktor Client and JsonPath.</p>
        <p>
            Continue to the next tutorial to learn how to <a href="server-create-static-website.md">create a static
            website</a>.
        </p>
    </chapter>
</topic>